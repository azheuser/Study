//#include类似define,文本插入 
//#include有两种形式来指出要插入的文件 
//-""首先找当前目录，再去编译器指定目录找
//-<>让编译器只在指定目录去找 

//#include的误区
//-#include不是用来引入库的 
//-stdio.h里只有printf的原型 

//头文件
//-在使用和定义这个函数的地方都应该有
//	#include这个头文件
//-一般的做法就是任何.c都有对应的同名的.h，
//	把所有对外公开的函数的原型和全局变量的声明都放进去 
//-只有声明可以被放在头文件中
//---是规则不是法律
//-否则会造成一个项目中多个编译单元里有重名的实体
//---*某些编译器允许几个编译单元中存在同名的函数，
//		或者用week修饰符来强调这种存在 

//不对外公开的函数
//-在函数前面加上static就使得它成为
//	只能在所在的编译单元中被使用的函数
//-在全局变量前加上static就使得它成为
//	只能在所在的编译单元被使用的全局变量

//变量的声明
//-int i;是变量的定义 
//-extern int i;是变量的声明 

//定义和声明
//-声明是不产生代码的东西
//---函数原型
//---变量声明
//---结构声明
//---宏声明
//---枚举声明
//---类型声明
//---inline函数
//-定义是产生代码的东西
//---函数定义
//---全局变量 
/***	For me 
函数的定义是定义, 函数的原型是声明 
变量的定义是定义, extern的变量的声明是声明
extern不能初始化
***/

//重复声明
//-同一个编译单元里，同名结构不能被重复声明
//-如果你的头文件里有结构的声明，
//	很难这个头文件不会在一个编译单元里被#include多次 
//-所以需要"标准头文件结构"

//标准头文件结构
/******
#ifndef __LIST_HEAD__
#define __LIST_HEAD__

#include"node.h"

typedef struct _list {
	Node* head;
	Node* tail;
} List; 

#endif	
*******/
//-运用条件编译和宏，保证这个头文件
//	在一个编译单元中只会被#include一次
//-#pragma once也能起到相同的作用(不是所有编译器支持) 

#include<stdio.h>
#include"max.h"
#include"min.h"

//double max(double a, double b);

//struct Node {
//	int value;
//	char* name;
//};

int main(void) {
	int a = 5;
	int b = 6;
	printf("%f\n", max(a, gALL));
	
	return 0;
}


